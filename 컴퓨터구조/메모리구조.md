## 메모리 영역

주로 보는 메모리 구조 이미지는 아래와 같다.

<img width="333" alt="image" src="https://github.com/PracticeEveryday/cs/assets/97580759/06e3090c-0f39-4e79-afb3-7bb473bfb391">

대개 4가지 영역로 표현되곤 한다. 

1. 코드 영역
2. 데이터 영역
3. 힙 영역
4. 스택 영역

> 🤔  프로그램은 어떻게 메모리를 관리할까?   
> 🤔  프로그램은 위의 이미지처럼 모두 연속적으로 할당 될까?
> -  위 이미지의 배경 박스는 데이터가 연속적으로 할당 되는 것 처럼 보인다.

### 가상 메모리
모든 프로그램은 `가상(假 거짓 가 想 생각 상) 메모리`라는 기술을 사용한다.

가상 메모리란 컴퓨터 시스템에서 `실제 물리적 메모리의 용량을 확장`하고 `효율적으로 관리`하기 위해 사용하는 `메모리 관리 기법`이다.

<img width="1044" alt="image" src="https://github.com/PracticeEveryday/cs/assets/97580759/c8b283a4-c875-44c8-8904-7082e4b638d4">

위 이미지는 [pep/9](https://computersystemsbook.com/5th-edition/pep9/) 이라는 프로그램이다.   
우측에 보이는 보드는 `가상 메모리`를 시각화하여 보여주는 데, 모든 메모리는 `0000`으로 시작하는 것을 볼 수 있다.   

만약, 우리가 두개의 프로그램을 동시에 실행 한다면 두 프로그램은 모두 `0000`으로 시작하는 주소를 읽게 될 것이고, OS에도 `0000`의 주소 데이터를 요청할 것이다.

> 🤔두 프로그램 모두 OS에게 `0000`에 접근해달라고 요청한다면 OS는 어떻게 이를 구분지을 수 있을까?   
> 🤔서로 다른 프로그램이 동일한 주소를 사용하는 것을 OS는 어떻게 구분할까?

### 프레임(frame)과 페이지(Page)
OS는 메모리를 `프레임과 페이지`라는 단위 개념으로 관리한다.   
- 프레임이란 `물리 메모리`를 일정한 크기로 나눈 단위이고,
- 페이지는 `가상 메모리`를 일정한 크기로 나눈 단위이다.

우리의 프로그램은 `페이지라는 단위`로 나뉜 뒤 `물리 메모리에 적재 된다`.   
➡️ 즉, 프로그램의 모든 코드가 적재 되지 않을 수도 있는 것이다.

> 🤔 왜 모든 프로그램을 한 번에 메모리에 적재하지 않아도 될까?? 

✅ 우리의 프로그램은 순차적으로 실행 된다.   
1번째 줄 실행 뒤 2번째 줄이 메모리에 적재되어 있다면 `일단` 프로그램을 실행하는 데 문제가 없다.

![img](https://github.com/PracticeEveryday/cs/assets/97580759/fcd1c72c-cd7f-4810-bde7-51a96b66715c)

### 페이지 테이블(Page Table)
운영체제는 프로그램을 `가상화된 단위로 나눈 페이지`와 이를 `실제로 할당된 물리 메모리의 단위 프레임`을 매핑 시켜 놓는 `Page Table`이라는 것을 관리한다.

<img width="438" alt="image" src="https://github.com/PracticeEveryday/cs/assets/97580759/fdc84311-ac2c-499e-8bd7-887723ab4a30">

위키 피디아에 그려져 있는 [페이지 테이블](https://en.wikipedia.org/wiki/Page_table) 왼쪽 이미지를 보면   
해당 파일의 가장 최근 이미지와 비슷하게 생긴 것을 확인할 수 있다.

또한, 전체적인 그림을 보면, 페이지 단위로 나누어진 좌측 이미지가 실제 메모리 공간을   
추상화한 우측 이미지와 `화살표`로 연결된 것도 확인할 수 있다.


> 페이지 테이블 예시를 한 번 보자

1. 페이지 크기: 4KB
2. 가상 주소 공간: 32KB (8 페이지)
3. 물리 메모리: 16KB (4 프레임)

| 가상 페이지 번호 | 물리 프레임 번호 | 유효 비트 (할당 여부) | 메모리 주소 범위 (가상)  | 메모리 주소 범위 (물리)  |
|-----------|-----------|---------------|-----------------|-----------------|
| 0         | 3         | 1             | 0x0000 - 0x0FFF | 0x3000 - 0x3FFF |
| 1         | 1         | 1             | 0x1000 - 0x1FFF | 0x1000 - 0x1FFF |
| 2         | -         | 0             | 0x2000 - 0x2FFF | -               |
| 3         | 0         | 1             | 0x3000 - 0x3FFF | 0x0000 - 0x0FFF |
| 4         | -         | 0             | 0x4000 - 0x4FFF | -               |
| 5         | 2         | 1             | 0x5000 - 0x5FFF | 0x2000 - 0x2FFF |
| 6         | -         | 0             | 0x6000 - 0x6FFF | -               |
| 7         | -         | 0             | 0x7000 - 0x7FFF | -               |

📝 운영 체제는 위와 같은 `페이지 테이블`을 활용하여 가상 메모리 기법을 관리한다!


#### Base register, Limit register, MMU(Memory Management Unit)

컴퓨터에는 `MMU`, `Base Register`, `Limit Register`라는 세 가지 하드웨어가 존재한다.   
운영 체제는 위 3가지를 활용하여 `물리 메모리`와 `가상 메모리` 사이의 `연결 다리`가 되어 준다.

1. `Base Register`
   1. 베이스 레지스터는 프로그램이 프로세스로 전환 되고, 메모리에 할당될 때의 `시작` 레지스터이다.
   2. `PCB(Process Control Block)` 에 저장된다.
2. `Limit Register`
   1. 한계 레지스터는 메모리에 적재된 프로세스가 사용할 수 있는 마지막 주소이다.
   2. `PCB(Process Control Block)` 에 저장된다.
3. `MMU`
   1. 운영체제는 `Memory Management Unit` 을 도움을 받아 물리 메모리와 가상 메모리의 주소 전환을 이루어 낸다.

> 아래는 MMU 하드웨어 이미지이다.
> > <img width="424" alt="image" src="https://github.com/PracticeEveryday/cs/assets/97580759/8bd092c5-76db-4d89-bc56-4a6d44051211">

CPU가 접근하기 위한 프로세스의 주소가 유효한 값인지 조회하는 플로우 차트는 아래와 같다

<img width="440" alt="image" src="https://github.com/PracticeEveryday/cs/assets/97580759/7fa6163f-51c4-4069-8b91-e4043f3bb0d9">

### 프로그램 실행 순서

1. 프로세스가 가상 주소에 접근 시도
   1. 프로그램의 가상 메모리 페이지 번호`page number`와 패이지 내에서의 특정 위치 `offset`을 전달
   2. 페이지 테이블에서 해당 프로그램의 페이지 번호 열을 조회 
2. 페이지가 존재하지 않으면 페이지 폴트 발생
3. CPU가 페이지 폴트 인터럽트 핸들러 호출
4. 디스크에서 필요한 페이지 로드
5. 페이지 테이블 업데이트
6. 가상 페이지를 새 물리 프레임에 매핑
7. 프로세스 재시작
8. 중단된 명령어 재시도, 정상 실행


### 생각 

> 🤔 프로그램은 어떻게 메모리를 관리할까?   
> 프로그램은 `가상 메모리` 기법으로 메모리를 관리한다.   
> 모든 프로그램은 추상화된 자기만의 메모리 주소를 가지게 되며 실제 메모리 주소에 대한 관리는 전혀 하지 않는다.


> 🤔  프로그램은 위의 이미지처럼 모두 연속적으로 할당 될까? <<위 이미지의 배경 박스는 데이터가 연속적으로 할당 되는 것 처럼 보인다.
> 
> 가상 메모리 주소는 연속적으로 할당된 것처럼 보인다. 하지만, 실제로 물리 메모리에 할당될 때에는 연속적으로 할당되지 않을 수도 있다.  

> 🤔두 프로그램 모두 OS에게 `0000`에 접근해달라고 요청한다면 OS는 어떻게 이를 구분지을 수 있을까?   
> 🤔서로 다른 프로그램이 동일한 주소를 사용하는 것을 OS는 어떻게 구분할까?
> 
> 서로 다른 프로그램이 동일한 주소를 요청할 때 OS는 PCB 내에 저장되어 있는 Base Register와 Limit Register, Page Table 내에 매핑 되어 있는 값들을 활용하여 구분한다 :)


### 참고 자료
- [MMU 위키피디아](https://en.wikipedia.org/wiki/Memory_management_unit)
- [Chapter Nine -- Main Memory -- Lecture Notes](https://www.cs.csustan.edu/~john/Classes/Previous_Semesters/CS3750_OperatingSys_I/2019_02_Spr/Notes/Chap09/09_MainMemory.html)


