## 명령어와 데이터

> 우리의 코드는 `명령어와 데이터의 모음`으로 이루어져 있다.

#### 🤔 왜 그럴까?

- 컴퓨터가 주로 실행하는 명령어는 `데이터 읽어오기`, `데이터 저장하기`, `연산하기`이다.
- 그럼 중요한 것은 `어디서 데이터를 읽어오고`, `어디에 저장하고`, `어떤 값을 연산해야하는가`이기 때문이다.

### 명령어의 구조

먼저, 컴퓨터 명령어 구조를 보자

| 명령어 | 주소 | 주소 | 주소 |     설명      |        예시        |      명령어 설명       |
|:---:|:--:|:--:|:--:|:-----------:|:----------------:|:-----------------:|
| 명령어 | O  | O  | O  | 3-주소 명령어 형식 | `ADD R1, R2, R3` | R2와 R3를 더해 R1에 저장 |
| 명령어 | O  | O  |    | 2-주소 명령어 형식 |   `MOV R1, R2`   |   R2의 값을 R1에 복사   |
| 명령어 | O  |    |    | 1-주소 명령어 형식 |     `INC R1`     |    R1의 값을 1 증가    |
| 명령어 |    |    |    | 0-주소 명령어 형식 |      `RET`       |     함수 호출을 반환     |

명령어는 `명령부`와 `자료부`로 이루어져 있다. << 데이터의 뜻이 `자료`라고 했었다!

1. 명령부 (Opcode): 명령어의 종류를 나타내며, CPU가 `어떤 동작을 수행해야 하는지`를 지정한다. 
   - 예를 들어, `덧셈, 곱셈, 메모리 읽기/쓰기 등의 연산, 입/출력`을 지시한다
2. 자료부 (Operands): 명령어가 처리할 데이터나 데이터의 위치(`메모리 주소, 레지스터` 등)를 나타 낸다.

> 😂 일단 컴퓨터 명령어 구조 자체가 `명령부`와 `자료부`로 나누어져 있다.



<br>

보통 우리는 `연산자`를 활용하여 명령어를 사용한다.

우리가 사용하는 연산자는 거의 대부분 `피연산자`가 없으면 안된다.   
아래 연산자 목록을 한 번 보자


| 연산자 유형  | 연산자  |               설명                |            예시             |
|:-------:|:----:|:-------------------------------:|:-------------------------:|
| 대입 연산자  | `=`  |          변수에 값을 대입합니다.          |         `x = 5;`          |
| 산술 연산자  | `+`  |           두 값을 더합니다.            |         `3 + 4;`          |
| 산술 연산자  | `-`  |            두 값을 뺍니다.            |         `7 - 2;`          |
| 산술 연산자  | `*`  |           두 값을 곱합니다.            |         `6 * 5;`          |
| 산술 연산자  | `/`  |     첫 번째 값을 두 번째 값으로 나눕니다.      |         `10 / 2;`         |
| 산술 연산자  | `%`  |     첫 번째 값을 두 번째 값으로 나눈 나머지     |         `7 % 3;`          |
| 비교 연산자  | `==` |       두 값이 서로 같은지 확인합니다.        |     `if (x == y) {}`      |
| 비교 연산자  | `!=` |       두 값이 서로 다른지 확인합니다.        |     `if (x != y) {}`      |
| 비교 연산자  | `>`  |   첫 번째 값이 두 번째 값보다 큰지 확인합니다.    |      `if (x > y) {}`      |
| 비교 연산자  | `<`  |   첫 번째 값이 두 번째 값보다 작은지 확인합니다.   |      `if (x < y) {}`      |
| 비교 연산자  | `>=` | 첫 번째 값이 두 번째 값보다 크거나 같은지 확인합니다. |     `if (x >= y) {}`      |
| 비교 연산자  | `<=` | 첫 번째 값이 두 번째 값보다 작거나 같은지 확인합니다. |     `if (x <= y) {}`      |
| 논리 연산자  | `&&` |     두 개의 조건이 모두 참인지 확인합니다.      | `if (x > 0 && x < 10) {}` |
| 단항 연산자  | `++` |          값을 1 증가시킵니다.           |          `x++;`           |
| 단항 연산자  | `--` |          값을 1 감소시킵니다.           |          `y--;`           |
| 접근 연산자  | `.`  |         객체의 멤버에 접근합니다.          |       `obj.member;`       |
| 비트 연산자  | `&`  |       두 값을 비트 AND 연산합니다.        |         `a & b;`          |
| 비트 연산자  | `^`  |       두 값을 비트 XOR 연산합니다.        |         `a ^ b;`          |
| 비트 연산자  | `~`  |        값을 비트 NOT 연산합니다.         |           `~a;`           |
| 시프트 연산자 | `<<` |        비트를 왼쪽으로 시프트합니다.         |         `x << 2;`         |
| 시프트 연산자 | `>>` |        비트를 오른쪽으로 시프트합니다.        |         `y >> 1;`         |

<br>
<br>

즉, 연산을 수행하기 위한 `데이터(값)`을 함께 전달해주어야 하는 것이다.

> 그럼 데이터(자료)는 어디에 저장되어 있을까?

1. 코드(파일)
   - 코드를 치며 연산을 하기 위한 데이터를 바로 입력해준다.
   - 다른 곳에 저장되어 있는 파일에서 데이터를 가져온다.
2. 데이터베이스
   - 저장해 놓은 데이터 베이스에서 연산을 하기 위한 값을 가져온다.

우리는 `데이터와 명령어로 이루어진 코드를 작성`하고 
➡️ 컴퓨터가 이해할 수 있는 언어로 컴파일을 한 뒤 
➡️ 컴퓨터에 일을 시킨다.

### 요약

> 우리는 컴퓨터에 특정 목적을 이루기 위한 일을 시키고 싶다.
> 
> 우리는 `연산자`와 `피연산자(값)`을 이용하여 컴퓨터에게 시킬 일(명령)을 코드로 작성한다.
> 
> `명령어의 구조`는 `명령부`와 `자료부`로 나뉜다.   
> 값(자료부)은 코드를 작성할 때 `바로 입력`하거나, `다른 파일`에서 가져오거나, `저장한 데이터베이스`에서 가져온다.   
> 
> 그럼 우리가 하는 일은
> 
> 1. 어떤 일을 시킬 지 정하기
> 2. 이 일을 시키기 위해서 필요한 연산자 고르기
> 3. 연산할 때 값 가져오기(다른 파일, 직접 작성, 데이터 베이스에서 가져오기)
> 4. 연산자와 값을 이용해 코드 작성하기
> 5. 컴파일 후 컴퓨터가 이해할 수 있는 언어로 변경하기
> 6. 컴퓨터에 일 시키기

### 예시 코드

```javascript
#include <stdio.h>

int main() {
    int num1 = 10; 
    num1 = 20;     
    int num2 = 20; 
    int num3 = num1 + num2;
    
    printf("%d\n", num3); // 20 출력
    return 0;
}
```
위 C언어와 아래 Assembly는 동일한 행위를 하는 코드이다.
```javascript
.LC0:
        .string "%d\n"
main:
        push    rbp
        mov     rbp, rsp
        sub     rsp, 16
        mov     DWORD PTR [rbp-4], 10
        mov     DWORD PTR [rbp-4], 20
        mov     DWORD PTR [rbp-8], 20
        mov     edx, DWORD PTR [rbp-4]
        mov     eax, DWORD PTR [rbp-8]
        add     eax, edx                    
        mov     DWORD PTR [rbp-12], eax
        mov     eax, DWORD PTR [rbp-12]
        mov     esi, eax
        mov     edi, OFFSET FLAT:.LC0
        mov     eax, 0
        call    printf
        mov     eax, 0
        leave
        ret
```


### 참고 자료

- [COMPILER EXPLORER](https://godbolt.org/)
- [x86 Assembly Language Programming](https://cs.lmu.edu/~ray/notes/x86assembly/)
