### 이제까지 데이터베이스와 관련된 내용을 읽었는데, 어플리케이션이 부호화와 어떤 상관관계를 지니는지에 대해 이야기 해보자.

2장은 데이터 모델, 3장은 데이터 베이스 저장 및 검색, 4장은 데이터 스키마의 변경과 전송에 대한 주제라고 생각했습니다.

책의 4장 p115 앞부분에 아래와 같은 내용이 나온다.

> 프로그램은 보통 (최소한) `두 가지 형태`로 표현된 데이터를 사용한다.   
>메모리에 객체, 구조체, 목록, 배열, 해시 테이블, 트리 등으로 `데이터가 유지` 된다. << CPU 접근 효율을 위해 포인터(주소)개념 도입   
>…   
>데이터를 파일에 쓰거나 네트워크를 통해 전송하려면 스스로를 포함한 일련의 `바이트열(Ex. JSON, XML)` 의 형태로 `부호화`해야한다. << 타 서버나 데이터베이스에 `포인터(주소)` 를 알려줘도 모른다.   
>…
>

데이터의 형식은 `해당 애플리케이션`이 사용하는 데이터 구조 또는 다른 형식의 어플리케이션, 데이터 베이스, 메시지 큐 등에 데이터를 전송하는 데이터 형식(`바이트 열`)이 있는 것이다.

**멧돼지 책의 주요 주제는 `데이터`이다. 데이터의 생김새가 2장, 데이터를 저장하고 조회하는 방법이 3장, 데이터** 변경과  **전송 방식을 4장에 걸쳐서 설명한 것 같다고 생각했다!**

### p131 데이터플로 모드에는 다양한 하나의 프로세스에서 다른 프로세스로 데이터를 전달하는 방식에 대한 내용을 알려주고 있다.

해당 방식중 비동기 메시지 전달을 통한 데이터 플로에 대한 내용이 나오는데 사용해 보았다면 사용해 본 경험과 사용 이유를 설명해보자.

비동기 큐를 통해 구현해 본적은 없지만, 사내에서 적용해 본적은 있습니다!(다른 분이 하고 이야기만 나눈 🙂)

비대면 진료를 받고 나면 `전자 서명` 을 받는 프로세스가 있었습니다!

EC2 내에 람다 펑션으로 네이티브 앱에서 서명한 이미지를 파일로 만드는 프로세스 였는데, 병렬로 한 번에 처리하니 CPU를 너무 많이 잡아 먹어서 서버가 죽어버린 적이 있었습니다!

[`nestjs/bull`](https://docs.nestjs.com/techniques/queues) 을 사용해서 레디스 Queue에 담아놓고 하나의 서명 작업이 끝나면 큐에서 꺼내오는 식으로 작업했습니다!

### 이진부호화 (스리프트, 프로토콜 버퍼, 아브로)를 실무에서 적용한다면 어디에 적용이 가능하며 효율적일 것인지 고민하고 이야기 해보자

스리프트, 프로토콜 버퍼, 아브로 등의 이진 부호화 방식은 프로그램 코드도 함께 활용 된다는 점이 장점이라고 생각했습니다.

[nestjs/grpc](https://docs.nestjs.com/microservices/grpc) 레퍼런스를 보면 아래와 같이 `protobuf` 데이터 구조를 활용하는 것을 볼 수 있습니다.

![image](https://github.com/user-attachments/assets/edd3b88d-cb97-4585-8def-9a7a3cca6cb3)

https://github.com/sergey-suslov/gRPC-nest-js-ar/blob/master/services/gateway/src/main.ts

위 레포지토리는 GRPC를 활용해 모노레포를 구성한 예시입니다.

RPC는 `Remote Procedure Call` 로 외부에 있는 서버의 프로세스를 활용할 수 있는 방법론입니다.

모노레포로 하나의 레포지토리에서 여러 프로젝트를 띄우고, RPC를 활용하여 타 서버에 있는 함수나 프로시저를 활용할 수 있다면 좋은 활용이 될 수 있을 것이라 생각했습니다.

더해서, 로직에 구현되어 있는 Protobuf 타입을 통해 어떤 스키마를 가지고 있는 지 확인할 수 있는 점도 좋은점 이라고 생각되었습니다 🙂

> 사용하는 언어와 프레임워크가 다르더라도 활용이 가능합니다.
>

RPC 통신은 Protobuff를 활용하여 부호화 할때 키를 바이트열에 포함하지 않고 보내게 됩니다.
하지만, 서로 다른 언어와 프레임워크로 구현된 서버는 바이트열에 존재하는 값에 대응되는 `키 값의 스키마`를 가지고 있게 되고, 약속한 형태의 바이너리로 변경할 수만 있다면 언어와 프레임워크는 병목으로 존재하지 않게 되는 것입니다.
![image](https://github.com/user-attachments/assets/3e14c2ea-0b54-483b-9563-072bf32a1b29)


오늘과 같이 마이크로서비스라는 키워드가 많이 소비될 때 다른 언어와 프레임워크로 띄어져 있는 각각의 서버들이 소통하는 데 효율적인 방법론이 될 수 있을 거라 생각됩니다!

키를 모두 바이트열에 담아서 전송하는 JSON, XML에 비해 용량이 적은 것도 큰 장점이 될 수 있습니다!

또한, 빠른 전송, 높은 성능, 언어 중립성, 양방향 스트리밍 등의 다양한 장점을 가지게 됩니다!

### 참고 자료 
- [gRPC - 알고 나면 쉬움](https://www.youtube.com/watch?v=uwrR5e5_FH8&ab_channel=얄팍한코딩사전)