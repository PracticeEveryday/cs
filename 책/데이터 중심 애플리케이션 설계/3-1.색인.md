### 저장소와 검색

> 가장 기본적인 수준에서 데이터베이스가 하는 작업은 크게 두가지이다.
1. 어떤 데이터를 받으면 저장한다.
2. 나중에 저장한 데이터를 요청하면 다시 데이터를 제공한다.

3장은 데이터베이스가 데이터를 저장하는 방법과 데이터를 요청했을 때 어떻게 찾는 지에 방법에 대해 알려준다.

저장소 엔진은 크게 두 가지로 나뉜다.

1. 트랜잭션 작업부하를 처리하는 엔진
2. 데이터 분석을 위해 최적화된 엔진 >> 칼럼 지향 저장소

> 가장 간단한 데이터베이스

```jsx
#!bin/bash

db_set() {
	echo "$1 $2" >> database
}

db_get() {
	grep "^$1," database | sed -e "s/^$1,//" | tail -n 1
}
```

키-값 저장소 데이터베이스로 `db_set` 은 key와 value를 저장하는 함수이고 `db_get` 은 해당 키와 연관된 가장 최근 값을 찾아 반환하는 함수이다.

위의 가장 간단한 데이터베이스의 특징은 다음과 같다.

1. `db_set` 을 호출할 때마다 파일의 끝에 추가만한다. << 덮어 쓰지 않는다.
2. `db_get` 함수는 성능이 좋지 않다 << 찾고 싶은 키값을 찾기 위해서는 항상 파일의 시작부터 끝을 스캔해야 한다.

> Log 파일(Append-Only 데이터 파일)
>

Log 파일은 항상 데이터를 추가하기만 하는 파일이다.

### 색인

O(n) 시간 복잡도를 이겨내기 위해 `색인` 이라는 개념을 사용한다.

색인은 데이터를 제외한 부가적인 `메타데이터`이다.

이 메타데이터는 이정표 역할을하여 찾고 싶은 데이터의 위치를 알려주는 데 도움을 준다.

> 색인의 특징

색인은 `Primary Key(기본키)` 에서 파생된 추가적인 구조이다.

데이터 베이스의 기본키는 항상 색인을 가지고 있으며 `CREATE INDEX` SQL을 활용하여 기본키 이외의 색인도 추가가 가능한다.

💡 색인을 사용하게 되면 따라오는 트레이드 오프는 `쓰기 속도 저하`이다.   
`>>` 새로운 데이터를 갱신할 때마다 매번 `색인` 도 갱신해야 되기 때문이다!

### 해시 색인

색인을 위해 `key-value(키-값) 데이터 구조` 를 활용해보자.

키-값 저장소는 사전 타입, 해시 맵, 해시 테이블 자료구조를 통해 구현한다.

> 가장 간단한 색인 방법
>

가장 간단하게 색인을 기록하는 방법은 `key에 동일한 key` 값을, value에는 디스크에 저장되어 있는 파일의 바이트 오프셋을 세팅해준다.

인메모리 해시 맵

| 바이트 오프셋 | 0 | 1 | 2 | 3 | 4 | … |
| --- | --- | --- | --- | --- | --- | --- |
|  | 1 | 2 | 3 | 4 | 5 | 6 |
| 바이트 오프셋 | 64 | 65 | 66 | 67 | 68 | … |
|  | 4 | 2 | , | { | “ | n |

이 가장 간단한 색인 방법은 실제로 많이 사용되며 `비트캐스트(리악(Riak)의 기본 저장소 엔진)`에서 활용되고 있다.

비트캐스트는 해시 맵을 전부 `메모리`에 저장하기 때문에, 사용 가능한 램에 모든 키가 저장되어 있다는 대전제가 깔려 있다.

비스캐스트 저장소 엔진은 각 키의 Value가 자주 갱신되는 상황에 적합하다.

예를 들면, 키가 키우는 고양이 동영상의 URL이고 값이 비디오가 재생된 횟수인 경우가 있다.

💡 키당 쓰기 수가 많지만 고유한 키는 많지 않다 << 비디오가 많지 않으며 비디오 URL을 클릭하는 횟수
즉, 쓰기 행위는 많다.

> 🤔  파일에 항상 추가만 된다면 디스크 공간이 부족해질텐데?
>

특정 크기의 `segment`로 로그를 나누어 저장하는 방식으로 해결할 수 있다.

로그 파일이 특정 크기에 도달하면 새로운 세그먼트 파일을 생성해 이후 쓰기를 수행한다.

> 컴팩션(Compaction)

이 후 컴팩션 작업을 거쳐 분리된 세그먼트 파일을 합치는 데 컴팩션이란 로그에서 중복된 키를 버리고 각 키의 최신 갱신 값만 유지하는 것을 의미한다.

| mew: 1 | purr: 39 | purr:40 | mew:2 | mew:3 | purr:41 |
| --- | --- | --- | --- | --- | --- |
| mew:4 | yawn: 400 | mew:5 | purr:42 | yawn:401 |  |

`>>` 컴팩션

| yarn: 401 | mew:5 | purr:42 |
| --- | --- | --- |

컴팩션의 장점은 여러 세그먼트 파일도 병합할 수 있는 것이다.

| mew: 1 | purr: 39 | purr:40 | mew:2 | mew:3 | purr:41 |
| --- | --- | --- | --- | --- | --- |

| mew: 5 | purr: 42 | purr:43 | mew:2 | mew:6 | purr:44 |
| --- | --- | --- | --- | --- | --- |

`>>` 컴팩션

> 💡 세그먼트 파일은 생성되고난 뒤에는 `절대` 변경될 수 없다. 그렇기에 병합하기 위한 새로운 세그먼트 파일을 만든다.
>

병합 과정이 끝난 이후의 읽기 요청은 병합한 새로운 세그먼트 파일을 사용하면 된다.

병합되기 이전 세그먼트 파일은 `삭제 처리`하면 된다!

또한, 각 세그먼트 파일은 메모리에 각각의 해시 테이블을 갖고 있게 된다.

만약, 찾고하는 키의 값이 없다면 최신 세그먼트 해시 테이블을 먼저 확인하고
최신 세그먼트에 없다면, 두 번째 최신 세그먼트 해시 테이블을 확인하는 과정을 쭈욱 거치면 된다.

하지만, 컴팩션 병합 과정을 통해 세그먼트 파일의 수를 적게 유지하기에 많은 해시 테이블을 확인할 필요가 없다.

> 추가 전용 로그 구현 시 생각해야할 사항
>
1. 파일형식
2. 레코드 삭제
3. 고장 복구
4. 부분적으로 레코드 쓰기
5. 동시성 제어

> 추가 전용 로그가 좋은 설계일 수 있는 케이스
>
1. 추가와 세그먼트 병합은 시간 순서 쓰기 작업이기 때문에 무작위(임의) 접근 쓰기보다 훨씬 빠르다.
2. 세그먼트 파일이 추가 전용 쓰기 작업이고, 불변하다면 고장 복구가 훨씬 간단하다.
    1. 갚을 덮어 쓰고 있는 상황에서 DB가 죽더라도 이전 값 부분과 새로운 값을 포함한 부분을 나누어 함께 저장하기 때문!
3. 오래된 세그먼트 병합은 `삭제`되므로 조각화되는 데이터 파일 문제를 피할 수 있다.

> 해시 테이블을 메모리에 색인하면 발생하는 이슈
>
1. 메모리에 저장하므로 키가 너무 많다면 이슈가 발생한다.
    1. 🤔 디스크에 해시맵을 저장한다면?
        1. 해도 문제가 없지만, 디스크에 해시맵은 좋은 성능을 기대하기 어렵다.
            1. 무작위 접근 I/O 처리 비용
            2. 디스크가 가득 찼을 때 확장 비용 + 해시 충돌 해소 처리 어려움
2. 해시 테이블을 범위 질의에 효과적이지 않다.
    1. 000~999 범위의 모든 것을 가져와라 << 해시 테이블은 인덱스 기준으로 값을 추론하기 때문에 범위 질의에 적합하지 않다!


### 출처
- [데이터 중심 애플리케이션 설계](https://m.yes24.com/Goods/Detail/59566585)