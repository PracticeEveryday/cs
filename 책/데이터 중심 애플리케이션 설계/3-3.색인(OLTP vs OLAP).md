## 트랜잭션 처리와 분석

> OLTP Online Transaction Processing
>

초창기 비즈니스 데이터 처리에서 쓰기가 보통 `판매`, `공급 업체에 발주`, `직원 급여 지불`, 과 같은 상거래 `Commercial Transaction`에 해당했다.

최근 금전 거래가 아닌 영역으로 데이터베이스가 확장 되었어도 `트랜잭션`이라는 용어는 논리 단위의 형태로서 읽기와 쓰기 그룹을 나타내고 있다!

데이터베이스가 상거래뿐 아니라 블로그 글의 댓글, 게임 액션, 주소록의 연락처 등 다양한 종류의 데이터를 사용하고 있지만, 기본적인 접근 패턴은 비즈니스 트랜잭션 처리와 아직도 유사하게 되어 있다.

➡️ 애플리케이션은 색인을 활용해 일부 키에 대한 적은 수의 레코드를 찾아낸다.

레코드는 사용자 입력을 기반으로 삽입되거나 갱신된다.

이런 애플리케이션은 `대화식`으로 이런 접근 패턴을 `온라인 트랜잭션 처리 Online Transaction Process OLTP` 라고 한다.

> OLAP Online Analytic Processing
>

최근에는 데이터베이스를 `데이터 분석`에도 점점 더 많이 사용한다.

데이터 분석은 OLTP와는 접근 패턴 자체가 다르다.

원시 데이터를 그대로 반환하는 것이 아니라 `많은 수`의 레코드를 스캔해 레코드 당 일부 칼럼만 읽어 집계(카운트, 합, 평균)통계를 계산한다.

```jsx
1. 1월의 각 매장의 총 수익은 얼마인가?
2. 최근 프로모션 기간 동안 평소보다 얼마나 더 많이 바나나를 판마했는가?
3. X 브랜드 기저귀와 함께 자주 구매하는 유아식 브랜드는 무엇인가?
```

이런 질의는 보통 비즈니스 분석가 또는 회사 경영진이 더 나은 의사결정을 위해 돕는 보고서 형식이다.

이런 데이터베이스 사용 패턴을 트랜잭션 처리와 구분하기 위해 `온라인 분석 처리`라고 한다.

> OLTP 와 OLAP의 주된 차이는 읽기에 대한 접근 방식이다.

OLTP는 그저 데이터를 쓴 그대로 읽어온다는 관점이다.
하지만 OLAP는 원시 데이터를 분석하여 어떤 `정보`를 뽑아와 제공한다는 점이 다르다.
>

| 특성                 | OLTP                         | OLAP                   |
|--------------------|------------------------------|------------------------|
| 주요 읽기 패턴           | 질의당 적은 수의 레코드                |                        |
| `키`를 기준으로 가져옴      | 많은 레코드에 대한 집계                |                        |
| 각 컬럼의 합, 평균, 최소값 등 |                              |                        |
| 주요 쓰기 패턴           | 임의 접근, 사용자 입력을 낮은 지연 시간으로 기록 | 대규모 불러오기(bulk, import) |
| 주요 사용처             | 웹 애플리케이션을 통한 최종 사용자/소비자      | 의사 결정을 위한 내부 분석가       |
| 데이터 표현             | 데이터 최신 상태(현재 시점)             | 시간이 지나면서 일어난 이벤트 이력    |
| 데이터셋 크기            | 기가 바이트~테라 바이트                | 테라 바이트~페타 바이트          |

처음에는 `트랜잭션 처리`와 `분석 질의` 를 위해 동일한 데이터베이스에서 사용해왔다.

하지만 시간이 지나면서 개별 데이터베이스에서 분석을 처리하는 경향을 보였는데 분석을 위한 데이터베이스를 `데이터 웨어하우스`라고 불렀다.

### 데이터 웨어하우징

현업에서는 웹 사이트 강화, 판매 관리 계산 시스템, 창고 재고 이력, 운송 수단 경로, 공급업체 관리, 직원 관리등의 수십 가지의 트랜잭션을 관리한다.

OLTP시스템은 사업 운영과 깊이 관여되어 있기에 일반적으로 높은 가용성과 지연 시간의 트랜잭션 처리를 기대한다.

그렇기에 데이터베이스 관리자는 OLTP 데이터베이스를 철저하게 보호한다.

➡️ 이는 비즈니스 분석가가 OLTP 데이터베이스에 즉석 분석 질의를 하는 것을 꺼린다.

분석질의는 많은 레코드의 집계를 필요로 하기에 많은 비용을 수반하기 때문이다.

즉석 분석 질의와 트랜잭션 작업이 동시에 일어난다면 성능이 저하되는 현상을 마주할 수 있다!

> 데이터 웨어하우스
>

데이터 웨어하우스는 OLTP 작업에 영향을 주지 않고 마음껏 질의할 수 있는 `질의용 개별 데이터베이스`이다.

즉, 다양한 OLTP 데이터베이스의 `읽기 전용 복사본`이다.

데이터 웨어하우스로 데이터를 가져오는 과정은 OLTP 데이터베이스에서 데이터를 추출하고, 분석 친화적인 스키마로 변환하는 과정을 거쳐 OLAP 데이터베이스에 적재하는 것이다.

1. OLTP에서 원시 데이터 추출
2. OLAP 전용 스키마로 데이터 정재
3. 깨끗하게 정재된 데이터 적재

이러한 과정을 `ETL(Extract-Transform-Load)`라고 부른다!

<img width="541" alt="image" src="https://github.com/user-attachments/assets/dd8c7574-d07a-4ec4-8d3b-e95c8bc84639">

데이터 웨어하우스를 통해서 분석 질의를 나누는 장점은 분석 접근 패턴에 맞게 최적화가 가능하다는 점이다.

### OLTP vs Data Warehouse

SQL은 기본적으로 분석 질의에 적합하기에 데이터 웨어하우스의 데이터 모델은 주로 관계형 데이터베이스를 사용한다. << SQL의 강력한 집계 함수를 제공한다.

표면적으로 데이터 웨어하우스와 관계형 OLTP 데이터베이스는 모두 SQL 질의 인터페이스를 제공하기에 비슷해 보일 수도 있다.

하지만, 이제는 트랜잭션 처리와 분석 작업 부하 모두 각각 패턴에 맞게 최적화 되어 있기에 각 서비스에 대한 내부는 완전히 다르게 구현되어 있다.

Ex) 마이크로소프트 SQL 서버, SAP 하나(HANA)는 동일한 관계형 제품에서 트랜잭션 처리와 데이터 웨어하우징을 각각 지원한다.

### 분석용 스키마(별모양 스키마)

> 별모양 스키마(차원 모델링) Star Schema(Dimensional Modeling)
>

별모양 스키마의 중심에는 `사실 테이블(Fact Table)`이 존재한다.

사실 테이블에는 `특정 시각에 발생한 이벤트`가 저장된다. << 고객 제품 구매

사실 테이블에는 개별 이벤트를 담게 되고, 칼럼은 크게 두 가지 특징으로 구현된다.

1. 일부 칼럼은 제품이 판매된 가격과 공급자로부터 구매한 비용들이 들어간다
2. 일부 칼럼은 다른 테이블을 가리키는 외래키가 들어간다.
    1. 이 다른 테이블을 `차원 테이블`이라고 부른다.
        1. 이 차원 테이블에는 아래 이벤트의 속성들이 들어간다.
            1. 누가
            2. 언제
            3. 어디서
            4. 무엇을
            5. 어떻게
            6. 왜

> 별모양 스키마는 테이블 관계가 시각화 될 때 사실 테이블이 가운데 있고 차원 테이블로 둘러싸고 있다는 사실에서 비롯되었다고 한다 🙂
>

> 눈꽃 모양 스키마는 별모양 스키마의 차원 테이블을 더 하위 차원으로 세분화하여 나타낸 스키마 형식을 말한다
>

## 칼럼 지향 저장소

사실 테이블에 엄청난 로우와 페타바이트 데이터가 존재한다면 분석 질의를 하는 데는 어려운 문제에 직면한다.

🔥 기본적으로 질의는 대규모의 `데이터 집계를 요구`하기 때문이다.

📌 차원 테이블은 보통 훨씬 적다(수백만 로우) << 언제 어디서 어떻게 왜 누가같은 육하원칙의 케이스는 발생하는 이벤트(사실)에 비해 규모가 적다

사실 테이블은 컬럼이 보통 100개 이상이지만 일반적인 데이터 웨어하우스의 질의는 한번에 4~5개의 칼럼에만 접근한다.

(분석용으로 `SELECT * ..`와 같은 질의는 거의 필요하지 않다)

```sql
# 사람들이 요일에 따라 신선한 과일을 사고 싶어하는 지 사탕을 더 사고 싶어 하는 지 분석하기
SELECT dim_date.weekday, dim_product.category, 
	SUM(fact_sails.queantity_ AS quantity_sold
FROM fact_sales
	JOIN dim_date ON fact_sales.date_key = dim_date.date_key
	JOIN dim_product ON fact_sales.product_sk = dim_product.product_sk
...
```

➡️ 위의 분석 질의의 경우 `3개의 칼럼`을 제외하고는 모두 필요 없다.

> 로우 지향 방식
>

대부분의 OLTP의 데이터베이스 저장소는 `로우 지향 방식`으로 데이터를 배치한다.

즉, 테이블의 한 로우는 모두 인접하게 저장되는 것이다.

`>>` 이는 문서 데이터베이스에서도 유사하다 전체 문서는 하나의 연속된 바이트 열로 저장한다.

⛔️ 만약, `fact_sales.product_sk`, `fact_sales.date_key` 두 컬럼 모두에 색인이 걸려있더라도,
분석질의를 위해서는 `모든 로우를 메모리에 적재`한 다음 구문을 해석을 진행해야 한다.

즉, 인접하게 저장되어 있는 로우를 모두 메모리에 적재하여 구문 분석 후 필터링을 진행하는 것이다.

> 칼럼 지향 방식
>

칼럼 지향 저장소의 개념은 모든 값을 하나의 로우에 인접하게 저장하지 않고, 컬럼별로 데이터를 저장하는 것이다.

➡️ 이를 통해 분석에 필요한 칼럼들만 읽은 후 구문 분석을 진행하면 된다.

| date_key | product_sk | store_sk | customer_sk | quantity | … |
|----------|------------|----------|-------------|----------|---|
| 141012   | 69         | 4        | NULL        | 1        |   |
| 141012   | 69         | 5        | NULL        | 2        |   |
| 141012   | 74         | 5        | 191         | 3        |   |
| 141013   | 31         | 3        | 202         | 2        |   |
| 141013   | 31         | 2        | NULL        | 3        |   |
| 141013   | 31         | 3        | NULL        | 3        |   |
- 컬럼 저장소 배치 예시

```sql
date_key file content: 141012, 141012, 141012, 141013, 141013, 141013

product_sk file content: 69, 69, 74, 31, 31, 31

store_sk file content: 4, 5, 5, 3, 2, 3

customer_sk file content: NULL, NULL, 191, 202, NULL, NULL

quantity file content: 1, 2, 3, 2, 3, 3
```

### 컬럼 저장소의 쓰기 작업

데이터 웨어하우스에서 컬럼 저장소는 합리적이다.

대부분의 분석 작업은 `대량의 읽기 전용 질의`가 대부분이기 때문이다.

하지만, 칼럼 저장소의 가장 큰 단점은 `쓰기를 어렵게 한다`는 점이다.

→ B트리와 같이 제자리 갱신(Update-in-place) 접근 방식은 불가능하다.

정렬된 테이블의 중간에 있는 로우 삽입을 원하는 경우에는 모든 컬럼 파일 자체를 재작성 해야하기 때문이다.

로우는 칼럼 안의 `위치` 에 따라 식별되기에 삽입은 `모든 칼럼 파일 모두 일관적으로 갱신`해야 한다.

> LSM 트리
>

여기서 LSM 트리는 좋은 대안이 될 수 있다.

모든 쓰기는 인메모리 저장소에 먼저 저장한 뒤 정렬된 구조에 추가하고 디스크에 쓸 준비를 해놓는다.

📌 여기서 인메모리 저장소가 `로우 지향인지, 컬럼 지향인지는 중요하지 않다`.

쓰기 데이터가 충분히 모이게 되면 디스크의 칼럼 파일에 병합하고 파일을 기록한다.

모든 데이터 웨어하우스가 컬럼 저장소일 필요는 없다.

전통적인 로우 지향 데이터베이스와 기타 아키텍처도 존재한다.

하지만, 컬럼 지향 저장소는 특정 컬럼에 대한 질의 속도가 굉장히 빠르기 때문에 급속도로 인기를 얻어가고 있다.

### 집계 데이터 큐브와 구체화 뷰

데이터 큐브와 구체화 뷰는 미리 데이터를 만들어 놓는 것이다.

즉, 특정 질의를 효과적으로 미리 계산해 놓는 것이다. << 집계되어 저장되어 있는 값을 가져오기만 하면 되기에 질의에 아주 효과적이다.

<img width="539" alt="image" src="https://github.com/user-attachments/assets/d27d907b-aa4c-4d03-886e-487275d7f293">

|  | 32 | 33 | 34 | 35 | … | 합계 |
| --- | --- | --- | --- | --- | --- | --- |
| 140101 | 10.0 | 12.2 | 13.2 | 5.3 |  | 40.7 |
| 140101 | 1.1 |  |  |  |  |  |
| 140101 | 2.5 |  |  |  |  |  |
| 140101 | 0 |  |  |  |  |  |
| … | … |  |  |  |  |  |
| 합계 | 13.6 |  |  |  |  | 총합 |

---

## 정리

3장의 주된 의문은 두 가지이다.

1. 데이터베이스에 데이터를 저장할 때 어떤 일이 일어날까?
2. 데이터베이스에서 데이터를 다시 질의 할 때 어떤 일이 일어날까?

고수준 저장소 엔진은 크게 두 가지 범주로 나뉜다.

1. 트랜잭션 최적화 엔진 OLTP
2. 분석 최적화 엔진 OLAP

> 트랜잭션 최적화 엔진 OLTP
>

트랜잭션 최적화 엔진은 사용자와 직접적으로 대면하는 데이터베이스이다.

그렇기에 대량의 쓰기, 읽기 요청을 받을 수 있다. 이런 부하를 처리하기 위해 보통 각 질의미다 `적은` 개수의 레코드만 다룬다.

Application은 키의 일부만 사용하는 레코드를 요청하게 되고 저장소는 색인을 통해 데이터를 찾아 반환한다.

이 때 `디스크 탐색`  이 주된 병목이다. (데이터가 어디에 있는 지 디스크를 주로 탐색함)

OLTP의 주요한 두가지 관점은 아래와 같다.

1. 로그 구조화 관점
    1. 파일 추가만 허용
    2. 오래된 파일 삭제 허용
    3. 파일의 갱신불가
        1. 비트캐스크, SSTable, LSM트리, 레벨DB, 카산드라, HBase, 루씬
2. B tree
    1. 제자리 갱신 관점에서 덮어씌우는 고정 크기 페이지 셋 디스크
    2. 모든 주요 관계형 데이터베이스에서 사용

> 분석 최적화 엔진 OLAP
>

비즈니스 분석가가 데이터를 분석하기 위해 다루는 데이터베이스이다.

OLTP와 대비해 적인 질의 개수를 다루지만 질의의 수준이 높으며 한 번의 질의에 수백만 개에 이르는 레코드를 스캔해야 한다.

이 때는 `디스크의 대역폭`이 주된 병목이다.(수백만개의 데이터 레코드를 매모리에 적재하는 등 대규모의 용량이 필요)

OLAP는 질의가 많은 수의 데이터를 스캔하기에 `색인`을 사용하는 방법은 적절하지 않다.

읽는 양을 최소화하여 디스크의 대역폭을 줄이기 위해 부호화 및 칼럼 지향 저장소를 활용하곤 한다.

> LSM 트리
>

로그 구조화 저장소 엔진은 비교적 최근에 개발 되었으며 핵심 아이디어는 `임의 접근 쓰기`를 `순차 접근 쓰기`로 바꾼 것이다.

1. 000~999 범위의 모든 것을 가져와라 << 해시 테이블은 인덱스 기준으로 값을 추론하기 때문에 범위 질의에 적합하지 않다!